// Code generated by protoc-gen-go. DO NOT EDIT.
// source: service.proto

/*
Package service is a generated protocol buffer package.

It is generated from these files:
	service.proto

It has these top-level messages:
	NodeAddress
	Response
	Empty
	Message
	Node
	NodeList
	Heartbeat
	LogLevel
*/
package service

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"

import (
	context "golang.org/x/net/context"
	grpc "google.golang.org/grpc"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type Status int32

const (
	// Unknown is the default node status of newly-created nodes.
	Status_UNKNOWN Status = 0
	// Alive indicates that a node is alive and healthy.
	Status_ALIVE Status = 1
	// Suspected indicates that a node is suspected of being dead.
	Status_SUSPECTED Status = 2
	// Dead indicatates that a node is dead and no longer healthy.
	Status_DEAD Status = 3
	// ForwardTo is a pseudo status used by message to indicate
	// the target of a ping request.
	Status_FORWARD_TO Status = 4
)

var Status_name = map[int32]string{
	0: "UNKNOWN",
	1: "ALIVE",
	2: "SUSPECTED",
	3: "DEAD",
	4: "FORWARD_TO",
}
var Status_value = map[string]int32{
	"UNKNOWN":    0,
	"ALIVE":      1,
	"SUSPECTED":  2,
	"DEAD":       3,
	"FORWARD_TO": 4,
}

func (x Status) String() string {
	return proto.EnumName(Status_name, int32(x))
}
func (Status) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

type Response_Code int32

const (
	Response_OK    Response_Code = 0
	Response_ERROR Response_Code = 1
)

var Response_Code_name = map[int32]string{
	0: "OK",
	1: "ERROR",
}
var Response_Code_value = map[string]int32{
	"OK":    0,
	"ERROR": 1,
}

func (x Response_Code) String() string {
	return proto.EnumName(Response_Code_name, int32(x))
}
func (Response_Code) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{1, 0} }

type LogLevel_Level int32

const (
	LogLevel_ALL   LogLevel_Level = 0
	LogLevel_TRACE LogLevel_Level = 1
	LogLevel_DEBUG LogLevel_Level = 2
	LogLevel_INFO  LogLevel_Level = 3
	LogLevel_WARN  LogLevel_Level = 4
	LogLevel_ERROR LogLevel_Level = 5
	LogLevel_FATAL LogLevel_Level = 6
	LogLevel_OFF   LogLevel_Level = 7
)

var LogLevel_Level_name = map[int32]string{
	0: "ALL",
	1: "TRACE",
	2: "DEBUG",
	3: "INFO",
	4: "WARN",
	5: "ERROR",
	6: "FATAL",
	7: "OFF",
}
var LogLevel_Level_value = map[string]int32{
	"ALL":   0,
	"TRACE": 1,
	"DEBUG": 2,
	"INFO":  3,
	"WARN":  4,
	"ERROR": 5,
	"FATAL": 6,
	"OFF":   7,
}

func (x LogLevel_Level) String() string {
	return proto.EnumName(LogLevel_Level_name, int32(x))
}
func (LogLevel_Level) EnumDescriptor() ([]byte, []int) { return fileDescriptor0, []int{7, 0} }

type NodeAddress struct {
	// a valid IPv4 or IPv6 address
	IP string `protobuf:"bytes,1,opt,name=IP" json:"IP,omitempty"`
	// the port number
	Port uint32 `protobuf:"varint,2,opt,name=port" json:"port,omitempty"`
}

func (m *NodeAddress) Reset()                    { *m = NodeAddress{} }
func (m *NodeAddress) String() string            { return proto.CompactTextString(m) }
func (*NodeAddress) ProtoMessage()               {}
func (*NodeAddress) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *NodeAddress) GetIP() string {
	if m != nil {
		return m.IP
	}
	return ""
}

func (m *NodeAddress) GetPort() uint32 {
	if m != nil {
		return m.Port
	}
	return 0
}

type Response struct {
	Code Response_Code `protobuf:"varint,1,opt,name=code,enum=service.Response_Code" json:"code,omitempty"`
}

func (m *Response) Reset()                    { *m = Response{} }
func (m *Response) String() string            { return proto.CompactTextString(m) }
func (*Response) ProtoMessage()               {}
func (*Response) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

func (m *Response) GetCode() Response_Code {
	if m != nil {
		return m.Code
	}
	return Response_OK
}

type Empty struct {
}

func (m *Empty) Reset()                    { *m = Empty{} }
func (m *Empty) String() string            { return proto.CompactTextString(m) }
func (*Empty) ProtoMessage()               {}
func (*Empty) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

type Message struct {
	Bytes []byte `protobuf:"bytes,1,opt,name=bytes,proto3" json:"bytes,omitempty"`
}

func (m *Message) Reset()                    { *m = Message{} }
func (m *Message) String() string            { return proto.CompactTextString(m) }
func (*Message) ProtoMessage()               {}
func (*Message) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *Message) GetBytes() []byte {
	if m != nil {
		return m.Bytes
	}
	return nil
}

type Node struct {
	Address *NodeAddress `protobuf:"bytes,1,opt,name=address" json:"address,omitempty"`
	// Age is the time since we last heard from this node, in milliseconds.
	Age uint32 `protobuf:"varint,2,opt,name=age" json:"age,omitempty"`
	// EmitCounter is the number of times remaining that current status will
	// be emitted by this node to other nodes.
	EmitCounter int32 `protobuf:"varint,3,opt,name=emitCounter" json:"emitCounter,omitempty"`
	// PingMillis is the milliseconds transpired between the most recent PING
	// to this node and its responded ACK. If this node has not yet been pinged,
	// this vaue will be PingNoData (-1). If this node's last PING timed out,
	// this value will be PingTimedOut (-2).
	PingMillis int32 `protobuf:"varint,4,opt,name=pingMillis" json:"pingMillis,omitempty"`
	// Timestamp is the timestamp of this node's last ping or status update,
	// in milliseconds from the epoch
	Timestamp uint32 `protobuf:"varint,5,opt,name=timestamp" json:"timestamp,omitempty"`
	Status    Status `protobuf:"varint,6,opt,name=status,enum=service.Status" json:"status,omitempty"`
}

func (m *Node) Reset()                    { *m = Node{} }
func (m *Node) String() string            { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()               {}
func (*Node) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *Node) GetAddress() *NodeAddress {
	if m != nil {
		return m.Address
	}
	return nil
}

func (m *Node) GetAge() uint32 {
	if m != nil {
		return m.Age
	}
	return 0
}

func (m *Node) GetEmitCounter() int32 {
	if m != nil {
		return m.EmitCounter
	}
	return 0
}

func (m *Node) GetPingMillis() int32 {
	if m != nil {
		return m.PingMillis
	}
	return 0
}

func (m *Node) GetTimestamp() uint32 {
	if m != nil {
		return m.Timestamp
	}
	return 0
}

func (m *Node) GetStatus() Status {
	if m != nil {
		return m.Status
	}
	return Status_UNKNOWN
}

type NodeList struct {
	Nodes []*Node `protobuf:"bytes,1,rep,name=nodes" json:"nodes,omitempty"`
}

func (m *NodeList) Reset()                    { *m = NodeList{} }
func (m *NodeList) String() string            { return proto.CompactTextString(m) }
func (*NodeList) ProtoMessage()               {}
func (*NodeList) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{5} }

func (m *NodeList) GetNodes() []*Node {
	if m != nil {
		return m.Nodes
	}
	return nil
}

type Heartbeat struct {
	Millis int32 `protobuf:"varint,1,opt,name=millis" json:"millis,omitempty"`
}

func (m *Heartbeat) Reset()                    { *m = Heartbeat{} }
func (m *Heartbeat) String() string            { return proto.CompactTextString(m) }
func (*Heartbeat) ProtoMessage()               {}
func (*Heartbeat) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{6} }

func (m *Heartbeat) GetMillis() int32 {
	if m != nil {
		return m.Millis
	}
	return 0
}

type LogLevel struct {
	Level LogLevel_Level `protobuf:"varint,1,opt,name=level,enum=service.LogLevel_Level" json:"level,omitempty"`
}

func (m *LogLevel) Reset()                    { *m = LogLevel{} }
func (m *LogLevel) String() string            { return proto.CompactTextString(m) }
func (*LogLevel) ProtoMessage()               {}
func (*LogLevel) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{7} }

func (m *LogLevel) GetLevel() LogLevel_Level {
	if m != nil {
		return m.Level
	}
	return LogLevel_ALL
}

func init() {
	proto.RegisterType((*NodeAddress)(nil), "service.NodeAddress")
	proto.RegisterType((*Response)(nil), "service.Response")
	proto.RegisterType((*Empty)(nil), "service.Empty")
	proto.RegisterType((*Message)(nil), "service.Message")
	proto.RegisterType((*Node)(nil), "service.Node")
	proto.RegisterType((*NodeList)(nil), "service.NodeList")
	proto.RegisterType((*Heartbeat)(nil), "service.Heartbeat")
	proto.RegisterType((*LogLevel)(nil), "service.LogLevel")
	proto.RegisterEnum("service.Status", Status_name, Status_value)
	proto.RegisterEnum("service.Response_Code", Response_Code_name, Response_Code_value)
	proto.RegisterEnum("service.LogLevel_Level", LogLevel_Level_name, LogLevel_Level_value)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// Client API for TamTam service

type TamTamClient interface {
	// Join adds remote node to the network
	Join(ctx context.Context, in *NodeAddress, opts ...grpc.CallOption) (*Response, error)
	// Leave removes a remote node from the network
	Leave(ctx context.Context, in *NodeAddress, opts ...grpc.CallOption) (*Response, error)
	// Broadcast sends an arbitrary data message to other
	// healthy nodes in the network.
	Broadcast(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Response, error)
	// Stream creates a stream with arbitrary broadcast messages
	// received from other nodes in the network.
	Stream(ctx context.Context, in *Empty, opts ...grpc.CallOption) (TamTam_StreamClient, error)
	// Monitor creates a stream with network status changes.
	Monitor(ctx context.Context, in *Empty, opts ...grpc.CallOption) (TamTam_MonitorClient, error)
	// NodeList creates a list containing information about
	// other nodes in the network.
	Nodes(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NodeList, error)
	// Healthy creates a list containing information about
	// all healthy nodes in the network
	Healthy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NodeList, error)
	// SetHeartbeat changes the frequency this nodes sends out
	// heartbeat messages to the network.
	SetHeartbeat(ctx context.Context, in *Heartbeat, opts ...grpc.CallOption) (*Response, error)
	// SetLogThreshold changes the log level the network agent output logs to the console
	SetLogThreshold(ctx context.Context, in *LogLevel, opts ...grpc.CallOption) (*Response, error)
	// Ping sends a ping message to another node in the network.
	Ping(ctx context.Context, in *NodeAddress, opts ...grpc.CallOption) (*Response, error)
	// LocalAddress returns the address of the local network agent.
	LocalAddress(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NodeAddress, error)
}

type tamTamClient struct {
	cc *grpc.ClientConn
}

func NewTamTamClient(cc *grpc.ClientConn) TamTamClient {
	return &tamTamClient{cc}
}

func (c *tamTamClient) Join(ctx context.Context, in *NodeAddress, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/service.TamTam/Join", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tamTamClient) Leave(ctx context.Context, in *NodeAddress, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/service.TamTam/Leave", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tamTamClient) Broadcast(ctx context.Context, in *Message, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/service.TamTam/Broadcast", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tamTamClient) Stream(ctx context.Context, in *Empty, opts ...grpc.CallOption) (TamTam_StreamClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_TamTam_serviceDesc.Streams[0], c.cc, "/service.TamTam/Stream", opts...)
	if err != nil {
		return nil, err
	}
	x := &tamTamStreamClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TamTam_StreamClient interface {
	Recv() (*Message, error)
	grpc.ClientStream
}

type tamTamStreamClient struct {
	grpc.ClientStream
}

func (x *tamTamStreamClient) Recv() (*Message, error) {
	m := new(Message)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tamTamClient) Monitor(ctx context.Context, in *Empty, opts ...grpc.CallOption) (TamTam_MonitorClient, error) {
	stream, err := grpc.NewClientStream(ctx, &_TamTam_serviceDesc.Streams[1], c.cc, "/service.TamTam/Monitor", opts...)
	if err != nil {
		return nil, err
	}
	x := &tamTamMonitorClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type TamTam_MonitorClient interface {
	Recv() (*Node, error)
	grpc.ClientStream
}

type tamTamMonitorClient struct {
	grpc.ClientStream
}

func (x *tamTamMonitorClient) Recv() (*Node, error) {
	m := new(Node)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *tamTamClient) Nodes(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NodeList, error) {
	out := new(NodeList)
	err := grpc.Invoke(ctx, "/service.TamTam/Nodes", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tamTamClient) Healthy(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NodeList, error) {
	out := new(NodeList)
	err := grpc.Invoke(ctx, "/service.TamTam/Healthy", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tamTamClient) SetHeartbeat(ctx context.Context, in *Heartbeat, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/service.TamTam/SetHeartbeat", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tamTamClient) SetLogThreshold(ctx context.Context, in *LogLevel, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/service.TamTam/SetLogThreshold", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tamTamClient) Ping(ctx context.Context, in *NodeAddress, opts ...grpc.CallOption) (*Response, error) {
	out := new(Response)
	err := grpc.Invoke(ctx, "/service.TamTam/Ping", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *tamTamClient) LocalAddress(ctx context.Context, in *Empty, opts ...grpc.CallOption) (*NodeAddress, error) {
	out := new(NodeAddress)
	err := grpc.Invoke(ctx, "/service.TamTam/LocalAddress", in, out, c.cc, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// Server API for TamTam service

type TamTamServer interface {
	// Join adds remote node to the network
	Join(context.Context, *NodeAddress) (*Response, error)
	// Leave removes a remote node from the network
	Leave(context.Context, *NodeAddress) (*Response, error)
	// Broadcast sends an arbitrary data message to other
	// healthy nodes in the network.
	Broadcast(context.Context, *Message) (*Response, error)
	// Stream creates a stream with arbitrary broadcast messages
	// received from other nodes in the network.
	Stream(*Empty, TamTam_StreamServer) error
	// Monitor creates a stream with network status changes.
	Monitor(*Empty, TamTam_MonitorServer) error
	// NodeList creates a list containing information about
	// other nodes in the network.
	Nodes(context.Context, *Empty) (*NodeList, error)
	// Healthy creates a list containing information about
	// all healthy nodes in the network
	Healthy(context.Context, *Empty) (*NodeList, error)
	// SetHeartbeat changes the frequency this nodes sends out
	// heartbeat messages to the network.
	SetHeartbeat(context.Context, *Heartbeat) (*Response, error)
	// SetLogThreshold changes the log level the network agent output logs to the console
	SetLogThreshold(context.Context, *LogLevel) (*Response, error)
	// Ping sends a ping message to another node in the network.
	Ping(context.Context, *NodeAddress) (*Response, error)
	// LocalAddress returns the address of the local network agent.
	LocalAddress(context.Context, *Empty) (*NodeAddress, error)
}

func RegisterTamTamServer(s *grpc.Server, srv TamTamServer) {
	s.RegisterService(&_TamTam_serviceDesc, srv)
}

func _TamTam_Join_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TamTamServer).Join(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.TamTam/Join",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TamTamServer).Join(ctx, req.(*NodeAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _TamTam_Leave_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TamTamServer).Leave(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.TamTam/Leave",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TamTamServer).Leave(ctx, req.(*NodeAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _TamTam_Broadcast_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Message)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TamTamServer).Broadcast(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.TamTam/Broadcast",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TamTamServer).Broadcast(ctx, req.(*Message))
	}
	return interceptor(ctx, in, info, handler)
}

func _TamTam_Stream_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TamTamServer).Stream(m, &tamTamStreamServer{stream})
}

type TamTam_StreamServer interface {
	Send(*Message) error
	grpc.ServerStream
}

type tamTamStreamServer struct {
	grpc.ServerStream
}

func (x *tamTamStreamServer) Send(m *Message) error {
	return x.ServerStream.SendMsg(m)
}

func _TamTam_Monitor_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(Empty)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(TamTamServer).Monitor(m, &tamTamMonitorServer{stream})
}

type TamTam_MonitorServer interface {
	Send(*Node) error
	grpc.ServerStream
}

type tamTamMonitorServer struct {
	grpc.ServerStream
}

func (x *tamTamMonitorServer) Send(m *Node) error {
	return x.ServerStream.SendMsg(m)
}

func _TamTam_Nodes_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TamTamServer).Nodes(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.TamTam/Nodes",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TamTamServer).Nodes(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TamTam_Healthy_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TamTamServer).Healthy(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.TamTam/Healthy",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TamTamServer).Healthy(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

func _TamTam_SetHeartbeat_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Heartbeat)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TamTamServer).SetHeartbeat(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.TamTam/SetHeartbeat",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TamTamServer).SetHeartbeat(ctx, req.(*Heartbeat))
	}
	return interceptor(ctx, in, info, handler)
}

func _TamTam_SetLogThreshold_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LogLevel)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TamTamServer).SetLogThreshold(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.TamTam/SetLogThreshold",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TamTamServer).SetLogThreshold(ctx, req.(*LogLevel))
	}
	return interceptor(ctx, in, info, handler)
}

func _TamTam_Ping_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(NodeAddress)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TamTamServer).Ping(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.TamTam/Ping",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TamTamServer).Ping(ctx, req.(*NodeAddress))
	}
	return interceptor(ctx, in, info, handler)
}

func _TamTam_LocalAddress_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(Empty)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(TamTamServer).LocalAddress(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/service.TamTam/LocalAddress",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(TamTamServer).LocalAddress(ctx, req.(*Empty))
	}
	return interceptor(ctx, in, info, handler)
}

var _TamTam_serviceDesc = grpc.ServiceDesc{
	ServiceName: "service.TamTam",
	HandlerType: (*TamTamServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "Join",
			Handler:    _TamTam_Join_Handler,
		},
		{
			MethodName: "Leave",
			Handler:    _TamTam_Leave_Handler,
		},
		{
			MethodName: "Broadcast",
			Handler:    _TamTam_Broadcast_Handler,
		},
		{
			MethodName: "Nodes",
			Handler:    _TamTam_Nodes_Handler,
		},
		{
			MethodName: "Healthy",
			Handler:    _TamTam_Healthy_Handler,
		},
		{
			MethodName: "SetHeartbeat",
			Handler:    _TamTam_SetHeartbeat_Handler,
		},
		{
			MethodName: "SetLogThreshold",
			Handler:    _TamTam_SetLogThreshold_Handler,
		},
		{
			MethodName: "Ping",
			Handler:    _TamTam_Ping_Handler,
		},
		{
			MethodName: "LocalAddress",
			Handler:    _TamTam_LocalAddress_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "Stream",
			Handler:       _TamTam_Stream_Handler,
			ServerStreams: true,
		},
		{
			StreamName:    "Monitor",
			Handler:       _TamTam_Monitor_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "service.proto",
}

func init() { proto.RegisterFile("service.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 676 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x54, 0xdd, 0x4e, 0xdb, 0x4c,
	0x10, 0xfd, 0x9c, 0xf8, 0x27, 0x99, 0x90, 0x60, 0x56, 0x88, 0x2f, 0xa5, 0x55, 0x1b, 0x99, 0x8b,
	0x46, 0x88, 0x1a, 0x08, 0xad, 0xb8, 0x76, 0xfe, 0x4a, 0x8a, 0x49, 0xd2, 0x8d, 0x29, 0xea, 0x55,
	0xb5, 0xc4, 0xab, 0x60, 0xc9, 0xf6, 0x46, 0xde, 0x25, 0x12, 0xef, 0xd1, 0x87, 0xe8, 0xeb, 0xf4,
	0x8d, 0x2a, 0xaf, 0x13, 0x03, 0x4d, 0x2e, 0xe8, 0x8d, 0x35, 0x3b, 0x73, 0xe6, 0xec, 0x1c, 0xcf,
	0xd1, 0x42, 0x95, 0xd3, 0x64, 0x11, 0x4c, 0xa9, 0x3d, 0x4f, 0x98, 0x60, 0xc8, 0x58, 0x1e, 0xad,
	0x53, 0xa8, 0x0c, 0x99, 0x4f, 0x1d, 0xdf, 0x4f, 0x28, 0xe7, 0xa8, 0x06, 0x85, 0xc1, 0xb8, 0xae,
	0x34, 0x94, 0x66, 0x19, 0x17, 0x06, 0x63, 0x84, 0x40, 0x9d, 0xb3, 0x44, 0xd4, 0x0b, 0x0d, 0xa5,
	0x59, 0xc5, 0x32, 0xb6, 0xbe, 0x42, 0x09, 0x53, 0x3e, 0x67, 0x31, 0xa7, 0xe8, 0x10, 0xd4, 0x29,
	0xf3, 0xa9, 0xec, 0xa8, 0xb5, 0xf6, 0xec, 0xd5, 0x2d, 0x2b, 0x80, 0xdd, 0x61, 0x3e, 0xc5, 0x12,
	0x63, 0xbd, 0x02, 0x35, 0x3d, 0x21, 0x1d, 0x0a, 0xa3, 0x4b, 0xf3, 0x3f, 0x54, 0x06, 0xad, 0x87,
	0xf1, 0x08, 0x9b, 0x8a, 0x65, 0x80, 0xd6, 0x8b, 0xe6, 0xe2, 0xc1, 0x7a, 0x07, 0xc6, 0x15, 0xe5,
	0x9c, 0xcc, 0x28, 0xda, 0x05, 0xed, 0xf6, 0x41, 0x50, 0x2e, 0xb9, 0xb7, 0x70, 0x76, 0xb0, 0x7e,
	0x2b, 0xa0, 0xa6, 0x03, 0x23, 0x1b, 0x0c, 0x92, 0x0d, 0x2d, 0x01, 0x95, 0xd6, 0x6e, 0x7e, 0xf9,
	0x13, 0x41, 0x78, 0x05, 0x42, 0x26, 0x14, 0xc9, 0x8c, 0x2e, 0x85, 0xa4, 0x21, 0x6a, 0x40, 0x85,
	0x46, 0x81, 0xe8, 0xb0, 0xfb, 0x58, 0xd0, 0xa4, 0x5e, 0x6c, 0x28, 0x4d, 0x0d, 0x3f, 0x4d, 0xa1,
	0xb7, 0x00, 0xf3, 0x20, 0x9e, 0x5d, 0x05, 0x61, 0x18, 0xf0, 0xba, 0x2a, 0x01, 0x4f, 0x32, 0xe8,
	0x0d, 0x94, 0x45, 0x10, 0x51, 0x2e, 0x48, 0x34, 0xaf, 0x6b, 0x92, 0xf9, 0x31, 0x81, 0xde, 0x83,
	0xce, 0x05, 0x11, 0xf7, 0xbc, 0xae, 0xcb, 0xbf, 0xb3, 0x9d, 0x0f, 0x38, 0x91, 0x69, 0xbc, 0x2c,
	0x5b, 0xc7, 0x50, 0x4a, 0x47, 0x76, 0x03, 0x2e, 0xd0, 0x01, 0x68, 0x31, 0xf3, 0xa5, 0xea, 0x62,
	0xb3, 0xd2, 0xaa, 0x3e, 0x13, 0x85, 0xb3, 0x9a, 0x75, 0x00, 0xe5, 0x0b, 0x4a, 0x12, 0x71, 0x4b,
	0x89, 0x40, 0x7b, 0xa0, 0x47, 0xd9, 0x80, 0x8a, 0x1c, 0x70, 0x79, 0xb2, 0x7e, 0x2a, 0x50, 0x72,
	0xd9, 0xcc, 0xa5, 0x0b, 0x1a, 0xa2, 0x0f, 0xa0, 0x85, 0x69, 0xb0, 0x5c, 0xd4, 0xff, 0x39, 0xed,
	0x0a, 0x61, 0xcb, 0x2f, 0xce, 0x50, 0xd6, 0x77, 0xd0, 0xb2, 0x3e, 0x03, 0x8a, 0x8e, 0xeb, 0x66,
	0xcb, 0xf2, 0xb0, 0xd3, 0xe9, 0x99, 0x4a, 0x1a, 0x76, 0x7b, 0xed, 0xeb, 0xcf, 0x66, 0x01, 0x95,
	0x40, 0x1d, 0x0c, 0xfb, 0x23, 0xb3, 0x98, 0x46, 0x37, 0x0e, 0x1e, 0x9a, 0xea, 0xe3, 0x5a, 0xb5,
	0x34, 0xec, 0x3b, 0x9e, 0xe3, 0x9a, 0x7a, 0x4a, 0x34, 0xea, 0xf7, 0x4d, 0xe3, 0x70, 0x00, 0x7a,
	0x26, 0x1f, 0x55, 0xc0, 0xb8, 0x1e, 0x5e, 0x0e, 0x47, 0x37, 0xc3, 0x8c, 0xdf, 0x71, 0x07, 0xdf,
	0x52, 0xfe, 0x2a, 0x94, 0x27, 0xd7, 0x93, 0x71, 0xaf, 0xe3, 0xf5, 0xba, 0xd9, 0x1d, 0xdd, 0x9e,
	0xd3, 0x35, 0x8b, 0xa8, 0x06, 0xd0, 0x1f, 0xe1, 0x1b, 0x07, 0x77, 0x7f, 0x78, 0x23, 0x53, 0x6d,
	0xfd, 0x52, 0x41, 0xf7, 0x48, 0xe4, 0x91, 0x08, 0x1d, 0x83, 0xfa, 0x85, 0x05, 0x31, 0xda, 0x68,
	0x82, 0xfd, 0x9d, 0x35, 0x5f, 0xa2, 0x93, 0x54, 0x21, 0x59, 0xd0, 0x7f, 0xe9, 0x28, 0xb7, 0x13,
	0x46, 0xfc, 0x29, 0xe1, 0x02, 0x99, 0x79, 0x7d, 0x69, 0xd7, 0x4d, 0x1d, 0x47, 0xa9, 0xd4, 0x84,
	0x92, 0x08, 0xd5, 0xf2, 0xa2, 0xb4, 0xf9, 0xfe, 0x5a, 0xfb, 0x89, 0x82, 0x0e, 0xc1, 0xb8, 0x62,
	0x71, 0x20, 0x58, 0xb2, 0x06, 0x7f, 0xee, 0x02, 0x89, 0xd5, 0xd2, 0x88, 0xaf, 0x21, 0x77, 0x9e,
	0x21, 0xa5, 0xa3, 0x8e, 0xc0, 0xb8, 0xa0, 0x24, 0x14, 0x77, 0x0f, 0x2f, 0x41, 0x7f, 0x82, 0xad,
	0x09, 0x15, 0x8f, 0xee, 0x42, 0x39, 0x24, 0xcf, 0x6d, 0x92, 0x7a, 0x0e, 0xdb, 0x13, 0x2a, 0x5c,
	0x36, 0xf3, 0xee, 0x12, 0xca, 0xef, 0x58, 0xe8, 0xa3, 0x9d, 0x35, 0x8f, 0x6d, 0x6a, 0x3c, 0x06,
	0x75, 0x1c, 0xc4, 0xb3, 0x97, 0xaf, 0xe1, 0x23, 0x6c, 0xb9, 0x6c, 0x4a, 0xc2, 0xfc, 0xc5, 0xfa,
	0x4b, 0xd3, 0x46, 0xa2, 0xf6, 0x11, 0xbc, 0x8e, 0x43, 0x5b, 0xc4, 0xcc, 0x5e, 0x9c, 0x9e, 0x9f,
	0x9e, 0xd9, 0x82, 0x44, 0x82, 0x44, 0x2b, 0x68, 0xbb, 0x92, 0xd9, 0x68, 0x9c, 0xbe, 0x8d, 0x63,
	0xe5, 0x56, 0x97, 0x8f, 0xe4, 0xd9, 0x9f, 0x00, 0x00, 0x00, 0xff, 0xff, 0xcf, 0x38, 0x01, 0x5b,
	0x35, 0x05, 0x00, 0x00,
}
